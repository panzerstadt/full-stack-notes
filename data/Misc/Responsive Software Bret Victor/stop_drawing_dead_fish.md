# Stop drawing dead fish

behaviour and responsiveness is the essence of the computer as an art medium
- anytime we create art that doesn't have behavious, we are not living up to the potential medium
- response between 'living' art and 'living' user/artist 

## PART 1 : mediums of representation

#### TLDR : behaviour in reaction to the performer (artist/programmer) is the next step in expression through the medium of the computer.

1. [a picture of a fish is not a fish](https://youtu.be/ZfytHvgHybA?t=5m28s)
- on paper, a silhouette of a fish is a decent representation of a fish, because that is about as much fishiness you can get out of the medium of representation
- but on a computer, if you draw a 2d picture of a fish, it is a terrible representation of a fish. you are not using the full extent of what the medium allows you to do to represent fishiness.

2. an animated fish [is still not a fish](https://youtu.be/ZfytHvgHybA?t=8m8s)
- if this were tv, this would be a pretty good representation of a fish. it captures about as much of the fishiness as we can capture on the medium of a tv (one way)
- but again, this is a terrible representation of a fish.

(does he mean designing this medium in terms of agents, objects that can behave and respond through design)

3. [performing fish](https://youtu.be/ZfytHvgHybA?t=12m20s)
- my fish is living in a simulation
- 60 times a second the computer asks the fish, 'what do you wanna do?'
- performance control
- what you're seeing here is the interplay between two living, **behaving** beings. there's the fish behaving through *simulation* and me behaving *through performance*, and there's this symbiosis where two of us are putting on a show. (not a 1 to 1 relationship, but a back and forth)
- a balance of **responsibilities** between **what the art should do and what the artist should do**

4. [the difference between expressing the feeling of emotion](https://youtu.be/ZfytHvgHybA?t=19m51s)
- differences between expression through drawing frames at the drafting table (animator) and experiencing it with you in performance
- because i'm here in this moment with you, I am experience that tension the same way you are experiencing it as an audience
- this ultimately leads to more emotional expressiveness in the art itself

## PART 2 : how an artist creates the behaviour

#### TLDR : the creation of that behaviour in terms of intuitiveness to the creator (artist/programmer)

1. [code is an inappropriate way of creating digital art](https://youtu.be/ZfytHvgHybA?t=21m21s)

how do we teach our digital objects to behave and respond?
- traditionally by code
- code is an inappropriate way of creating digital art

reason 1
- reason being i can't see what i'm creating
- visual art has always been done through the direct manipulation of the art medium (but nowadays the medium is code)
- an indirect representation (code) is very unartistic

reason 2
- has to do with language and visual understanding
- code is language (we think linguistically when we are coding)
- to him the reason why we create visual art is because **they want to express something they can't express through language**

> artists draw because they want to convey something that they can't describe.

unless it's code, because

### code is a linguistic hack that we can use to describe a scene (e.g. starry night) unambiguously

but it is a completely wrong way of creating that scene.

#### creating behaviour through the direct manipulation of art objects

('geometric manipulations on these art objects' he says. perhaps the language of geometry itself is a finite, unambiguous description of most of the world, enough so that they can be a complete subset of what constitutes behaviour.)

(so, geometry - solved.)

(the key is in allowing the user to create OPERATIONS without code so that they can manipulate geometry easily. it is the next layer of abstraction (like grasshopper))

- [performance control (i'm using my left hand to say 'how to move' and my right hand to say 'where to move')](https://youtu.be/ZfytHvgHybA?t=33m16s)

- we have two different ways of modelling the world
	1. algebraically
	2. geometrically

- [the reason we have these two ways is because they correspond to two different facilities in our mind.](https://youtu.be/ZfytHvgHybA?t=34m43s)
- algebra corresponds to our linguistic facilities
- geometry corresponds to out visual facilities

#### there should be a geometric approach to creating art, because it corresponds to the visual facilities in our brain

[so what we have here we is an implementation of a spring model](https://youtu.be/ZfytHvgHybA?t=39m19s)
- (like one from any physics code library).
- the difference here is that it is expressed geometrically.

[time counter implemented geometrically](https://youtu.be/ZfytHvgHybA?t=40m15s)
- if you think about how periodic events occur in nature, there's probably a circle involved.

> everything we draw should be alive by default (in order to be native art in the pc as the medium)

## PART 3 : a live performance

[a performance](https://youtu.be/ZfytHvgHybA?t=49m22s)

i've given these pictures behaviours
- they don't know what to do, they just know how to **listen to my hand**

(an interactive piece called 'listen to my hand' where things react in various ways to the user's hand?)


## continuing from the video

[reader](https://medium.com/the-atlantic/the-coming-software-apocalypse-4ffb43f3b288)

```
It’s not quite Photoshop. The beauty of Photoshop, of course, is that the picture you’re manipulating on the screen is the final product. In model-based design, by contrast, the picture on your screen is more like a blueprint. Still, making software this way is qualitatively different than traditional programming. In traditional programming, your task is to take complex rules and translate them into code; most of your energy is spent doing the translating, rather than thinking about the rules themselves. In the model-based approach, all you have is the rules. So that’s what you spend your time thinking about. It’s a way of focusing less on the machine and more on the problem you’re trying to get it to solve.```

problem:
```
“Computing is fundamentally invisible,” Gerard Berry said in his talk. “When your tires are flat, you look at your tires, they are flat. When your software is broken, you look at your software, you see nothing.”
```